"""
Задания по олимпиадному программированию


1. Крестьянин и черт

Максимальное время: 0,1 с.
Максимальная память: 4 MB
Идет крестьянин и плачется: "Эхма! Жизнь моя горькая! Заела нужда совсем! Вот в кармане только несколько монет, да и те сейчас нужно отдать. И как это у других бывает, что на всякие свои деньги они еще деньги получают? Хоть бы кто помочь мне захотел".
Только успел это сказать, как глядь, а перед ним черт стоит и говорит: "Вот видишь этот мост через реку. Стоит тебе перейти через мост, и у тебя будет вдвое больше денег, чем есть. Перейдешь опять, и снова станет вдвое больше. Но за то, что я у тебя деньги удваиваю, после каждого перехода ты мне должен отдавать по K монет".
"Ой ли," - сказал крестьянин -"ну-ка, попробуем". Перешел мост, и деньги у него удвоились. Отдал он черту K монет, перешел мост еще раз, и опять деньги удвоились. Снова отдал крестьянин черту K монет.
Однако после Z переходов и отдач черту по K монет оказалось, что у крестьянина не осталось ни одной монеты.
Требуется определить, сколько комбинаций условий перехода через мост может быть, если известно, что у крестьянина изначально было не более MaxN монет. Комбинацией условий перехода является тройка чисел N, K, Z, где N - начальное количество монет у крестьянина, K - количество монет, отдаваемых черту после каждого перехода, Z - количество переходов. Естественно, что для этой тройки должно выполняться условие, что после Z циклов у крестьянина не должно остаться монет.
Входной файл содержит целое число MaxN - максимальное количество, которое может быть изначально у крестьянина (1  MaxN  2000000000).
Выходной файл должен содержать одно целое число - количество комбинаций условий перехода через мост.
Пример:
Input.txt
3
Output.txt
4
Пояснение: возможны комбинации условий перехода
N K Z
1 2 1
2 4 1
3 6 1
3 4 2
"""
from typing import final

"""


mN = int(input())

tmp = 0
z = 1
while True:
    d = (2 ** z) - 1


print(tmp)
"""


# tmp = 0
# for n in range(1, int(input()) + 1):
#     if n == 1:
#         print(n, n)
#         tmp += 1
#         continue
#
#     for k in range(n, (n * 2) + 1):
#         m = (n * 2) / k
#         if int(m) * k == n * 2:
#             print(n, k, m)
#             tmp += 1
"""
tmp = 0
ww = 3
for x in range(1, (ww * 2) + 1):
    if x == 1:
        tmp += 1
        continue
        
    for y in range(2, x + 1):
        if x % y == 0 and x != y:
            print(x, y, )
            tmp += 1

print(tmp)
"""

# Матрица N * N,
# 1. Определить номера столбцов с однинаковыми элементами
"""
import math

def www(x, start):
    a = []
    tmp = None
    for z, q in enumerate(x[start:]):
        if tmp is None:
            tmp = q
        if tmp == q:
            a.append(z + start)  
    if len(a) != 1:
        print(a)



matrix = [[1, 2, 0, 2, 3],
          [2, 2, 2, 2, 3],
          [0, 2, 1, 2, 4],
          [1, 2, 1, 2, 5]]

columns = list(map(list, zip(*matrix)))

cc = []
for i in range(len(columns)):
    cc.append([str(columns[i]).count('0'), sum(columns[i]), math.prod(columns[i])])

for i in range(len(cc)):
    www(cc, i)
"""
# 2. Определить положение элементов значение которых является минимальный строке и максимальным столбце на пересечение которых на пересечение которых они стоят (или наоборот)

matrix = [[2, 1, 3],
          [4, -5, 6],
          [7, -8, 9]]

matrix = [[1, 2, 1],
          [6, 7, 7],
          [2, 9, 1]]

columns = list(map(list, zip(*matrix)))

for i in range(len(matrix)):
    for y in range(len(columns)):
        if max(matrix[i]) == min(columns[y]):
            print(i + 1, y + 1)



# 3. Матрица квадратная, определить является ли она магическим квадратом
"""
matrix = [[1, 2, 3],
          [3, 1, 2],
          [2, 3, 1]]

columns = list(map(list, zip(*matrix)))

for i in range(len(matrix)):
    if sum(matrix[i]) == sum(columns[i]):
        continue
    else:
        print("Не равно")
        exit(0)

print("Равно")
"""
